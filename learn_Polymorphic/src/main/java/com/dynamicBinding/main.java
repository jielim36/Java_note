package com.dynamicBinding;

public class main {

    //dynamic binding 动态绑定机制
    //


    public static void main(String[] args) {

        A test = new B();
        System.out.println(test.sum());//40
        System.out.println(test.sum1());//30

        System.out.println(test.sum2());//当运行类型没有sum2方法时去到父类得到了该方法，但是该方法内部的方法父类和子类都有，此时是重新回到运行类型开始寻找方法
                                        //也就是说每次调用方法都是从运行类型的地方开始寻找，没有就往父类找，之后有其他的方法又回到运行类型开始找
/*s

当对象调用方法时，会先去运行类型开始调用，如果没有就去父类找
如果需要调用属性时，则直接从现在的类调用（比如被调用到父类的方法后需要属性则直接获取父类的属性而不是回去子类重新找属性）
如果对象调用方法时子类没有该方法所以去到父类调用后，方法内又有需要调用方法时此时需要调用的方法是运行类型也有的方法则回去运行类型调用
也就是说每次的调用方法都是从对象的运行类型开始寻找

java的动态绑定机制原理：
1. 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定
2. 当调用方法的属性时， 没有动态绑定机制，哪里声明，那里使用


* */

    }

}
